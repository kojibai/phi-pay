# KCS-1 — Canonical Serialization (for hashing and signing)

KCS-1 defines a canonical byte representation of JSON values so that independent implementations can
compute identical hashes for the same logical object.

KCS-1 is designed to be implementable in any language.

---

## Scope

KCS-1 applies when computing:

- object hashes (content addressing)
- checkpoints
- signatures (if used)

It does not constrain how JSON is stored or pretty-printed for humans; it only defines the canonical bytes used for verification.

---

## Canonical JSON rules (normative)

Given an input JSON value, the canonical form is produced as follows:

1. **Encoding:** output bytes MUST be UTF-8.
2. **Objects:**
   - keys MUST be unique
   - keys MUST be emitted in lexicographic order (Unicode codepoint order)
3. **Arrays:** elements MUST be emitted in the given order.
4. **Whitespace:** no insignificant whitespace is permitted.
5. **Strings:** MUST be JSON-escaped as required by RFC 8259.
   - Implementations MUST NOT escape characters unnecessarily (e.g. MUST NOT escape `/`).
6. **Numbers:**
   - MUST be finite (no NaN, no Infinity).
   - For conformance in Krystal v1, numbers SHOULD be integers.
   - Integers MUST be emitted in base-10 with no leading `+` and no leading zeros (except `0` itself).
7. **Booleans and null:** MUST be emitted as `true`, `false`, and `null`.

---

## Canonical hash input

When a spec says “hash the object”, it means:

`sha256( KCS1( object ) )`

Where `KCS1(object)` is the UTF-8 bytes of the canonical JSON encoding.

---

## Implementation note

This repository includes a reference canonicalizer in `reference/python/krystal/canonical.py`
and test vectors in `test-vectors/canonical_vectors.json`.

Independent implementations MUST match the test vectors exactly.

