# KKS-1.0 — Kairos Lattice and Closure Mapping

KKS-1.0 maps an integer **pulse** into a deterministic daily coordinate:

- `dayIndex` (0-based)
- `beat` (0..35)
- `stepIndex` (0..43)
- `pulseInStep` (0..10)

The mapping is **pure integer math** and **closes the day exactly**.

---

## Constants

KKS-1.0 is defined by the following constants:

- `MICRO = 1_000_000` μpulses per pulse
- `N_DAY = 17_491.270421` pulses/day
- `N_DAY_MU = 17_491_270_421` μpulses/day  (exact integer)
- `BEATS_PER_DAY = 36`
- `STEPS_PER_BEAT = 44`
- `PULSES_PER_STEP = 11`

Derived:

- `GRID_PULSES_PER_DAY = BEATS_PER_DAY * STEPS_PER_BEAT * PULSES_PER_STEP = 17_424`
- `GRID_PULSES_PER_BEAT = STEPS_PER_BEAT * PULSES_PER_STEP = 484`

---

## Why μpulses exist

The lattice has `17,424` grid-pulses/day, but the physical day is `17,491.270421` pulses/day.

The difference is:

- `Δ = N_DAY - GRID_PULSES_PER_DAY = 67.270421 pulses/day`
- `Δ_MU = N_DAY_MU - GRID_PULSES_PER_DAY * MICRO = 67_270_421 μpulses/day`

KKS-1.0 accounts for this by mapping into the lattice using the exact day length `N_DAY_MU`,
which distributes the remainder across the day by slightly stretching each grid-pulse in time.

---

## Mapping algorithm (normative)

Input:

- `pulse` MUST be a non-negative integer.

Steps:

1. Convert pulse to μpulses:

   `P_MU = pulse * MICRO`

2. Compute day index and remainder (Euclidean division):

   `dayIndex = floor(P_MU / N_DAY_MU)`  
   `r_MU = P_MU - dayIndex * N_DAY_MU`

   Where `0 <= r_MU < N_DAY_MU`.

3. Map into the daily lattice (grid index):

   `gridIndex = floor(r_MU * GRID_PULSES_PER_DAY / N_DAY_MU)`

   This MUST satisfy: `0 <= gridIndex <= GRID_PULSES_PER_DAY - 1`.

4. Decode beat/step/pulse:

   `beat = floor(gridIndex / GRID_PULSES_PER_BEAT)`  
   `stepIndex = floor((gridIndex mod GRID_PULSES_PER_BEAT) / PULSES_PER_STEP)`  
   `pulseInStep = gridIndex mod PULSES_PER_STEP`

---

## Coordinate conventions

- `beat`, `stepIndex`, and `pulseInStep` are **0-based**.
- A human-facing display MAY add 1 to any field for UI purposes, but verification MUST use the 0-based values.

---

## Reference pseudocode

```text
function kks_1_0(pulse):
    MICRO = 1_000_000
    N_DAY_MU = 17_491_270_421
    GRID = 17_424
    GRID_PER_BEAT = 484
    PULSES_PER_STEP = 11

    P_MU = pulse * MICRO
    dayIndex = P_MU // N_DAY_MU
    r_MU = P_MU - dayIndex * N_DAY_MU

    gridIndex = (r_MU * GRID) // N_DAY_MU

    beat = gridIndex // GRID_PER_BEAT
    stepIndex = (gridIndex % GRID_PER_BEAT) // PULSES_PER_STEP
    pulseInStep = gridIndex % PULSES_PER_STEP

    return {dayIndex, beat, stepIndex, pulseInStep, gridIndex, r_MU}
```

---

## Test vector (normative)

Pulse `9,777,777` MUST map to:

- `beat = 0`
- `stepIndex = 14`

(See `test-vectors/kks_vectors.json` for additional vectors.)

